{
  "CPPTemp": {
  "prefix": "CPPNoTests",
  "body": [
    "//      ﷽",
    "",
    "// وَالَّذينَ جاهَدوا فينا لَنَهدِيَنَّهُم سُبُلَنا وَإِنَّ اللَّهَ لَمَعَ المُحسِنينَ",
    "",
    "#include <bits/stdc++.h>",
    "",
    "using namespace std;",
    "",
    "#define Besm_Allah       ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);",
    "#define int              long long",
    "",
    "void Atr23() {",
    "    ",
    "}",
    "",
    "signed main() {",
    "    Besm_Allah",
    "    Atr23();",
    "    return 0;",
    "}"
  ],
  "description": "CPPTemp"
},
  "CPTemp": {
  "prefix": "CPPTests",
  "body": [
    "//      ﷽",
    "",
    "// وَالَّذينَ جاهَدوا فينا لَنَهدِيَنَّهُم سُبُلَنا وَإِنَّ اللَّهَ لَمَعَ المُحسِنينَ",
    "",
    "#include <bits/stdc++.h>",
    "",
    "using namespace std;",
    "",
    "#define Besm_Allah       ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);",
    "#define int              long long",
    "",
    "",
    "void Atr23(int testcase) {",
    "    ",
    "}",
    "",
    "signed main() {",
    "    Besm_Allah",
    "    // freopen(\"input.txt\", \"r\", stdin);",
    "    // freopen(\"output.txt\", \"w\", stdout);",
    "    int T = 1;",
    "    cin >> T;",
    "    for (int testcase = 1; testcase <= T; ++testcase) {",
    "        // cout << \"Case #\" << testcase << \": \";",
    "        Atr23(testcase);",
    "    }",
    "    return 0;",
    "}"
  ],
  "description": "CPTemp"
},
  "DoubleHashing": {
  "prefix": "DoubleHashing",
  "body": [
    "mt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());",
    "",
    "template<typename T>",
    "T rand(T l, T r) {",
    "    return uniform_int_distribution<T>(l, r)(rng);",
    "}",
    "",
    "struct Hash {",
    "private:",
    "    const int mod1 = 1e9 + 7, mod2 = 1e9 + 9;",
    "    int base1, base2;",
    "    int n;",
    "    vector<int> pw1, pw2, hash1, hash2;",
    "",
    "    vector<int> hash(string &s, vector<int> &pw, const int mod) {",
    "        vector<int> res(n);",
    "        res[0] = (s[0] - 'a' + 1);",
    "        for (int i = 1; i < n; i++) {",
    "            res[i] = 1LL * (s[i] - 'a' + 1) * pw[i] % mod + res[i - 1];",
    "            if (res[i] >= mod) res[i] -= mod;",
    "        }",
    "        return res;",
    "    }",
    "    ",
    "    int query(vector<int> &hash, vector<int> &pw, int l, int r, const int mod) {",
    "        int res = hash[r];",
    "        if (l > 0) res -= hash[l - 1];",
    "        if (res < 0) res += mod;",
    "        res = 1LL * res * pw[n - l] % mod;",
    "        return res;",
    "    }",
    "public:",
    "    Hash(string &s) {",
    "        n = s.size();",
    "        base1 = rand((int) 1e6, (int) 1e8);",
    "        base2 = rand((int) 1e6, (int) 1e8);",
    "        pw1.resize(n + 1), pw2.resize(n + 1);",
    "        pw1[0] = pw2[0] = 1;",
    "        for (int i = 1; i <= n; i++) {",
    "            pw1[i] = 1LL * base1 * pw1[i - 1] % mod1;",
    "            pw2[i] = 1LL * base2 * pw2[i - 1] % mod2;",
    "        }",
    "        hash1 = hash(s, pw1, mod1);",
    "        hash2 = hash(s, pw2, mod2);",
    "    }",
    "",
    "    long long get_hash(int l, int r) {",
    "        return 1LL * query(hash1, pw1, l, r, mod1) *",
    "               query(hash2, pw2, l, r, mod2);",
    "    }",
    "};",
    ""
  ],
  "description": "DoubleHashing"
}, 
"SingleHashing": {
  "prefix": "SingleHashing",
  "body": [
    "mt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());",
    "",
    "template<typename T>",
    "T rand(T l, T r) {",
    "    return uniform_int_distribution<T>(l, r)(rng);",
    "}",
    "",
    "struct Hash {",
    "private:",
    "    const int mod1 = 1e9 + 7;",
    "    int base1;",
    "    int n;",
    "    vector<int> pw1, hash1;",
    "",
    "    vector<int> hash(string &s, vector<int> &pw, const int mod) {",
    "        vector<int> res(n);",
    "        res[0] = (s[0] - 'a' + 1);",
    "        for (int i = 1; i < n; i++) {",
    "            res[i] = 1LL * (s[i] - 'a' + 1) * pw[i] % mod + res[i - 1];",
    "            if (res[i] >= mod) res[i] -= mod;",
    "        }",
    "        return res;",
    "    }",
    "    ",
    "    int query(vector<int> &hash, vector<int> &pw, int l, int r, const int mod) {",
    "        int res = hash[r];",
    "        if (l > 0) res -= hash[l - 1];",
    "        if (res < 0) res += mod;",
    "        res = 1LL * res * pw[n - l] % mod;",
    "        return res;",
    "    }",
    "public:",
    "    Hash(string &s) {",
    "        n = s.size();",
    "        base1 = rand((int) 1e6, (int) 1e8);",
    "        pw1.resize(n + 1);",
    "        pw1[0] = 1;",
    "        for (int i = 1; i <= n; i++) {",
    "            pw1[i] = 1LL * base1 * pw1[i - 1] % mod1;",
    "        }",
    "        hash1 = hash(s, pw1, mod1);",
    "    }",
    "    ",
    "    long long get_hash(int l, int r) {",
    "        return 1LL * query(hash1, pw1, l, r, mod1);",
    "    }",
    "};"
  ],
  "description": "SingleHashing"
},
"Compression": {
  "prefix": "CoordinateCompression",
  "body": [
    "struct coordinate_compression {",
    "private:",
    "    vector<long long> comp;",
    "",
    "    void compress() {",
    "        sort(comp.begin(), comp.end());",
    "        comp.erase(unique(comp.begin(), comp.end()), comp.end());",
    "    }",
    "",
    "public:",
    "    coordinate_compression(vector<long long> & v) {",
    "        comp = v; ",
    "        compress(); ",
    "    }",
    "",
    "    int get_index(long long val) {",
    "        return lower_bound(comp.begin(), comp.end(), val) - comp.begin(); ",
    "    }",
    "",
    "    int get_origin(size_t idx) {",
    "        return comp[idx]; ",
    "    }",
    "};"
  ],
  "description": "Compression"
}, 
"DisjointUnion": {
  "prefix": "DSU",
  "body": [
    "struct DSU {",
    "    vector<int> leader, rank;",
    "",
    "    DSU(int n) {",
    "        leader.resize(n + 1);",
    "        rank.resize(n + 1);",
    "        for (int i = 0; i <= n; ++i) {",
    "            leader[i] = i;",
    "            rank[i] = 1;",
    "        }",
    "    }",
    "",
    "    int find_leader(int u) {",
    "        return leader[u] = leader[u] == u ? u : find_leader(leader[u]);",
    "    }",
    "",
    "    bool is_same_set(int u, int v) {",
    "        return find_leader(u) == find_leader(v);",
    "    }",
    "",
    "    bool unite(int u, int v) {",
    "        u = find_leader(u), v = find_leader(v);",
    "        if (u == v) return false;",
    "",
    "        if (rank[u] > rank[v]) swap(u, v);",
    "",
    "        leader[u] = v;",
    "        rank[v] += rank[u];",
    "        return true;",
    "    }",
    "};"
  ],
  "description": "DisjointUnion"
},
"KMP": {
  "prefix": "KMP",
  "body": [
    "vector<int> buildLPS(string &pattern) {",
    "    int sz = (int)pattern.size();",
    "    vector<int> lps(sz, 0); ",
    "    int len = 0; ",
    "",
    "    for (int i = 1; i < sz; ++i) {",
    "        if (pattern[i] == pattern[len]) {",
    "            lps[i] = ++len;",
    "        } else {",
    "            if (len != 0) {",
    "                len = lps[len - 1];",
    "                --i; ",
    "            } else {",
    "                lps[i] = 0;",
    "            }",
    "        }",
    "    }",
    "    return lps;",
    "}",
    "",
    "bool KMP(string &s, string &pat) {",
    "    vector<int> lps = buildLPS(pat); ",
    "    int i = 0, j = 0; ",
    "    while (i < (int)s.size()) {",
    "        if (s[i] == pat[j]) {",
    "            i++;",
    "            j++;",
    "            if (j == (int)pat.size()) return true; ",
    "        } else {",
    "            if (j != 0) {",
    "                j = lps[j - 1];",
    "            } else {",
    "                i++;",
    "            }",
    "        }",
    "    }",
    "    return false; ",
    "}",
    ""
  ],
  "description": "KMP"
},
"NaiveSieve": {
  "prefix": "Sieve",
  "body": [
    "constexpr int N = 1e6 + 5;",
    "vector<bool> is_prime(N, true); ",
    "void NaiveSieve(long long n) {",
    "    is_prime[0] = is_prime[1] = false;",
    "    for (long long i = 2; i <= n; i++) {",
    "        if (is_prime[i]) { ",
    "            for (long long j = i + i; j <= n; j += i) {",
    "                is_prime[j] = false;  ",
    "            }",
    "        }",
    "    }",
    "}"
  ],
  "description": "NaiveSieve"
},
"PrimeFactors": {
  "prefix": "PrimeFactors",
  "body": [
    "vector<long long> primeFactors(long long x) {",
    "    vector<long long> factors;",
    "    for (int i = 2; i * i <= x; ++i) {",
    "        while (x % i == 0) {",
    "            factors.push_back(i);",
    "            x /= i;",
    "        }",
    "    }",
    "",
    "    if (x > 1) {",
    "        factors.push_back(x);",
    "    }",
    "",
    "    return factors;",
    "}"
  ],
  "description": "PrimeFactors"
},
"SegmentTree": {
  "prefix": "SegmentTree",
  "body": [
    "struct Node {",
    "    int sum;",
    "",
    "    Node() : sum(0) { }",
    "    Node(int x) : sum(x) { }",
    "    void change(int x) {",
    "        sum = x;",
    "    }",
    "};",
    "",
    "struct Sagara {",
    "#define LeftChild  (node * 2 + 1)",
    "#define RightChild (node * 2 + 2)",
    "#define mid        (l + r >> 1)",
    "",
    "private:",
    "    vector<Node> segData;",
    "    int tree_size;",
    "",
    "    void build(vector<int> &arr, int node, int l, int r) {",
    "        if (r - l == 1) {",
    "            if (l < arr.size()) {",
    "                segData[node] = Node(arr[l]);",
    "            }",
    "            return;",
    "        }",
    "",
    "        build(arr, LeftChild, l, mid);",
    "        build(arr, RightChild, mid, r);",
    "",
    "        segData[node] = merge(segData[LeftChild], segData[RightChild]);",
    "    }",
    "",
    "    Node merge(Node &l, Node &r) {",
    "        Node ans = Node();",
    "        ans.sum = l.sum + r.sum;",
    "        return ans;",
    "    }",
    "",
    "    void update(int idx, int val, int node, int l, int r) {",
    "        if (r - l == 1) {",
    "            segData[node].change(val);",
    "            return;",
    "        }",
    "",
    "        if (idx < mid) {",
    "            update(idx, val, LeftChild, l, mid);",
    "        } else {",
    "            update(idx, val, RightChild, mid, r);",
    "        }",
    "",
    "        segData[node] = merge(segData[LeftChild], segData[RightChild]);",
    "    }",
    "",
    "    Node query(int left, int right, int node, int l, int r) {",
    "        if (l >= left and r <= right) return segData[node];",
    "        if (l >= right or left >= r) return Node();",
    "",
    "        Node L = query(left, right, LeftChild, l, mid);",
    "        Node R = query(left, right, RightChild, mid, r);",
    "",
    "        return merge(L, R);",
    "    }",
    "",
    "public:",
    "    Sagara(int n, vector<int> &arr) {",
    "        tree_size = 1;",
    "        while (tree_size < n) tree_size <<= 1;",
    "        segData = vector<Node>(2 * tree_size);",
    "        build(arr, 0, 0, tree_size);",
    "    }",
    "",
    "    void update(int idx, int val) {",
    "        update(idx, val, 0, 0, tree_size);",
    "    }",
    "",
    "    int query(int left, int right) {",
    "        return query(left, right, 0, 0, tree_size).sum;",
    "    }",
    "",
    "#undef LeftChild",
    "#undef RightChild",
    "#undef mid",
    "};"
  ],
  "description": "SegmentTree"
},
"SegmentTreeWithLazy": {
  "prefix": "SegmentTreeWithLazy",
  "body": [
    "struct Node {",
    "    int sum, lazy = 0;",
    "    bool isLazy = false;",
    "",
    "    Node() : sum(0) { }",
    "    Node(int x) : sum(x) {}",
    "    void updateNode(int x, int lx, int rx) {",
    "        sum += x * (rx - lx);",
    "        lazy += x;",
    "        isLazy = true;",
    "    }",
    "};",
    "",
    "",
    "struct SagaraWithLazy {",
    "#define leftChild  (node * 2 + 1)",
    "#define rightChild (node * 2 + 2)",
    "#define mid        ((lx + rx >> 1))",
    "",
    "    int treeSize;",
    "    vector<Node> segData;",
    "",
    "    void build(int node, int lx, int rx, vector<int>& arr) {",
    "        if (rx - lx == 1) {",
    "            if (lx < (int)arr.size())",
    "                segData[node] = Node(arr[lx]);",
    "            return;",
    "        }",
    "",
    "        build(leftChild, lx, mid, arr);",
    "        build(rightChild, mid, rx, arr);",
    "",
    "        segData[node] = merge(segData[leftChild], segData[rightChild]);",
    "    }",
    "",
    "    Node merge(Node& L, Node& R) {",
    "        Node res = Node();",
    "        res.sum = L.sum + R.sum;",
    "        return res;",
    "    }",
    "",
    "",
    "    void propagate(int node, int lx, int rx) {",
    "        if (rx - lx == 1 or !segData[node].isLazy) return;",
    "",
    "        segData[leftChild].updateNode(segData[node].lazy, lx, mid);",
    "        segData[rightChild].updateNode(segData[node].lazy, mid, rx);",
    "",
    "        segData[node].isLazy = segData[node].lazy = 0;",
    "    }",
    "",
    "    void update(int l, int r, int x, int node, int lx, int rx) {",
    "        propagate(node, lx, rx);",
    "",
    "        if (l >= rx or lx >= r) return;",
    "        if (l <= lx and rx <= r) {",
    "            segData[node].updateNode(x, lx, rx);",
    "            return;",
    "        }",
    "",
    "        update(l, r, x, leftChild, lx, mid);",
    "        update(l, r, x, rightChild, mid, rx);",
    "",
    "        segData[node] = merge(segData[leftChild], segData[rightChild]);",
    "    }",
    "",
    "",
    "    Node query(int l, int r, int node, int lx, int rx) {",
    "        propagate(node, lx, rx);",
    "",
    "        if (l >= rx or lx >= r) return Node();",
    "        if (l <= lx and rx <= r) {",
    "            return segData[node];",
    "        }",
    "",
    "        Node left = query(l, r, leftChild, lx, mid);",
    "        Node right = query(l, r, rightChild, mid, rx);",
    "",
    "        return merge(left, right);",
    "    }",
    "",
    "public:",
    "    SagaraWithLazy(int n, vector<int>& arr) {",
    "        treeSize = 1;",
    "        while (treeSize < n) treeSize <<= 1;",
    "        segData = vector<Node>(treeSize << 1);",
    "        build(0, 0, treeSize, arr);",
    "    }",
    "",
    "    void update(int l, int r, int x) {",
    "        update(l, r, x, 0, 0, treeSize);",
    "    }",
    "",
    "    int query(int l, int r) {",
    "        return query(l, r, 0, 0, treeSize).sum;",
    "    }",
    "#undef LeftChild",
    "#undef RightChild",
    "#undef mid",
    "};"
  ],
  "description": "SegmentTreeWithLazy"
},
"CheckIsBipartite": {
  "prefix": "CheckBibartite",
  "body": [
    "vector<int> color(N);",
    " ",
    "bool dfs_check_bipartite(int u) {",
    "    bool can = true;",
    "    for (auto v: adj[u]) {",
    "        if (!color[v]) {",
    "            color[v] = 3 - color[u];",
    "            can &= dfs_check_bipartite(v);",
    "        } else if (color[v] == color[u]) {",
    "            return false;",
    "        }",
    "    }",
    "    return can;",
    "}",
    " ",
    "bool bfs_check_bipartite(int st) {",
    "    queue<int> q;",
    "    q.push(st);",
    "    color[st] = 1;",
    "    while (!q.empty()) {",
    "        int u = q.front();",
    "        q.pop();",
    " ",
    "        for (auto v: adj[u]) {",
    "            if (!color[v]) {",
    "                color[v] = 3 - color[u];",
    "                q.push(v);",
    "            } else if (color[u] == color[v]) {",
    "                return false;",
    "            }",
    "        }",
    "    }",
    "    return true;",
    "}"
  ],
  "description": "CheckIsBipartite"
},
"fastPower": {
  "prefix": "fastPower",
  "body": [
    "long long fastPower(long long base, long long power, long long mod) {",
    "    long long res = 1;",
    "    while (power) {",
    "        if (power & 1) {",
    "            res = ((res % mod) * (base % mod)) % mod;",
    "            power -= 1;",
    "        } else {",
    "            base = ((base % mod) * (base % mod)) % mod;",
    "            power >>= 1;",
    "        }",
    "    }",
    "    return res;",
    "}"
  ],
  "description": "fastPower"
},
"multiplyStringWithInteger": {
  "prefix": "multiplyStringWithInteger",
  "body": [
    "string multiplyStrings(string a, int b) {",
    "    string result = \"\";",
    "    int carry = 0;",
    "    for (int i = a.size() - 1; i >= 0; i--) {",
    "        int prod = (a[i] - '0') * b + carry;",
    "        result = char((prod % 10) + '0') + result;",
    "        carry = prod / 10;",
    "    }",
    "    while (carry) {",
    "        result = char((carry % 10) + '0') + result;",
    "        carry /= 10;",
    "    }",
    "    return result;",
    "}"
  ],
  "description": "multiplyStringWithInteger"
},
"PrefixFrequencyCharacters": {
  "prefix": "PrefixFrequencyCharacters",
  "body": [
    "constexpr int N = 1e5+5;",
    "vector<vector<int>> prefix_freq(N, vector<int>(26, 0));",
    "void pre(string s) {",
    "    prefix_freq[0][s[0] - 'a'] = 1;",
    " ",
    "    for (int i = 1; i < sz(s); ++i) {",
    "        for (int ch = 0; ch < 26; ++ch)",
    "            prefix_freq[i][ch] = prefix_freq[i - 1][ch];",
    " ",
    "        prefix_freq[i][s[i] - 'a']++;",
    "    }",
    "}",
    " "
  ],
  "description": "PrefixFrequencyCharacters"
},
"Debugger": {
  "prefix": "ShowDebug",
  "body": [
    "#define debug(x)         cout << #x << \" = \" << x << \"\\n\";",
    "#define vdebug(a)        cout << #a << \" = \"; for(auto x: a) cout << x << \" \"; cout << \"\\n\";"
  ],
  "description": "Debugger"
},
"PrefixSum2D": {
  "prefix": "PrefixSum2D",
  "body": [
    "struct prefix_2D {",
    "    int n, m;",
    "    vector<vector<int>> pre;",
    "",
    "    prefix_2D(const vector<vector<int>> & matrix) {",
    "        n = matrix.size() - 1;",
    "        m = matrix[0].size() - 1;",
    "        pre = vector (n + 1, vector<int> (m + 1));",
    "",
    "        buildPrefix2D(matrix);",
    "    }",
    "",
    "    void buildPrefix2D(const vector<vector<int>> & matrix) {",
    "        for (int i = 1; i <= n; ++i) {",
    "            for (int j = 1; j <= m; ++j) {",
    "                pre[i][j] = matrix[i][j] + pre[i][j - 1] + pre[i - 1][j] - pre[i - 1][j - 1];",
    "            }",
    "        }",
    "    }",
    "",
    "    void printPrefix() {",
    "        for (int i = 1; i <= n; ++i) {",
    "            for (int j = 1; j <= m; ++j) {",
    "                cout << pre[i][j] << \" \\n\"[j == m];",
    "            }",
    "        }",
    "    }",
    "",
    "    int query(int x1, int y1, int x2, int y2) {",
    "        if (x1 > x2) swap(x1, x2);",
    "        if (y1 > y2) swap(y1, y2);",
    "        return pre[x2][y2] - pre[x1 - 1][y2] - pre[x2][y1 - 1] + pre[x1 - 1][y1 - 1];",
    "    }",
    "};"
  ],
  "description": "PrefixSum2D"
},
"SparseTable": {
  "prefix": "SparseTable",
  "body": [
    "template<typename T, class CMP = function<T(const T &, const T &)>> ",
    "struct Sparse_Table {",
    "    int n;",
    "    CMP merge;",
    "    vector<vector<T>> sp;",
    "",
    "    Sparse_Table(const vector<T>& arr, const CMP &F) : merge(F) {",
    "        n = arr.size();",
    "        int maxLog = 32 - __builtin_clz(n);",
    "        sp.resize(maxLog);",
    "        sp[0] = arr;",
    "        for (int lg = 1; lg < maxLog; ++lg) {",
    "            sp[lg].resize(n - (1 << lg) + 1);",
    "            for (int i = 0; i + (1 << lg) <= n; ++i) {",
    "                sp[lg][i] = merge(sp[lg - 1][i], sp[lg - 1][i + (1 << (lg - 1))]);",
    "            }",
    "        }",
    "    }",
    "",
    "    T query(int l, int r) {",
    "        int lg = __lg(r - l + 1);",
    "        return merge(sp[lg][l], sp[lg][r - (1 << lg) + 1]);",
    "    }",
    "};"
  ],
  "description": "SparseTable"
},"OrederedSet": {
  "prefix": "getOrederedSet",
  "body": [
    "#include <ext/pb_ds/assoc_container.hpp>",
    "#include <ext/pb_ds/tree_policy.hpp>",
    "using namespace __gnu_pbds;",
    "typedef tree<int, null_type, less<int>, rb_tree_tag,",
    "    tree_order_statistics_node_update>",
    "    ordered_set;"
  ],
  "description": "OrederedSet"
},"GPHashMap": {
  "prefix": "getHashMap",
  "body": [
    "#include<ext/pb_ds/assoc_container.hpp>",
    "#include<ext/pb_ds/tree_policy.hpp>",
    "using namespace std;",
    "using namespace __gnu_pbds;",
    "",
    "struct custom_hash {",
    "  static uint64_t splitmix64(uint64_t x) {",
    "    x += 0x9e3779b97f4a7c15;",
    "    x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;",
    "    x = (x ^ (x >> 27)) * 0x94d049bb133111eb;",
    "    return x ^ (x >> 31);",
    "  }",
    "  size_t operator()(uint64_t x) const {",
    "    static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();",
    "    return splitmix64(x + FIXED_RANDOM);",
    "  }",
    "};",
    "",
    "gp_hash_table<int, int, custom_hash> hashmap;"
  ],
  "description": "GPHashMap"
},
}
