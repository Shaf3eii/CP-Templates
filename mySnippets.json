{
  "CPPTemp": {
  "prefix": "CPPNoTests",
  "body": [
    "//      ﷽",
    "",
    "// وَالَّذينَ جاهَدوا فينا لَنَهدِيَنَّهُم سُبُلَنا وَإِنَّ اللَّهَ لَمَعَ المُحسِنينَ",
    "",
    "#include <bits/stdc++.h>",
    "",
    "using namespace std;",
    "",
    "#define Besm_Allah       ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);",
    "#define int              long long",
    "",
    "void Atr23() {",
    "    ",
    "}",
    "",
    "signed main() {",
    "    Besm_Allah",
    "    Atr23();",
    "    return 0;",
    "}"
  ],
  "description": "CPPTemp"
},
  "CPTemp": {
  "prefix": "CPPTests",
  "body": [
    "//      ﷽",
    "",
    "// وَالَّذينَ جاهَدوا فينا لَنَهدِيَنَّهُم سُبُلَنا وَإِنَّ اللَّهَ لَمَعَ المُحسِنينَ",
    "",
    "#include <bits/stdc++.h>",
    "",
    "using namespace std;",
    "",
    "#define Besm_Allah       ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);",
    "#define int              long long",
    "",
    "",
    "void Atr23(int testcase) {",
    "    ",
    "}",
    "",
    "signed main() {",
    "    Besm_Allah",
    "    // freopen(\"input.txt\", \"r\", stdin);",
    "    // freopen(\"output.txt\", \"w\", stdout);",
    "    int T = 1;",
    "    cin >> T;",
    "    for (int testcase = 1; testcase <= T; ++testcase) {",
    "        // cout << \"Case #\" << testcase << \": \";",
    "        Atr23(testcase);",
    "    }",
    "    return 0;",
    "}"
  ],
  "description": "CPTemp"
},
  "DoubleHashing": {
  "prefix": "DoubleHashing",
  "body": [
    "mt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());",
    "",
    "template<typename T>",
    "T rand(T l, T r) {",
    "    return uniform_int_distribution<T>(l, r)(rng);",
    "}",
    "",
    "struct Hash {",
    "private:",
    "    const int mod1 = 1e9 + 7, mod2 = 1e9 + 9;",
    "    int base1, base2;",
    "    int n;",
    "    vector<int> pw1, pw2, hash1, hash2;",
    "",
    "    vector<int> hash(string &s, vector<int> &pw, const int mod) {",
    "        vector<int> res(n);",
    "        res[0] = (s[0] - 'a' + 1);",
    "        for (int i = 1; i < n; i++) {",
    "            res[i] = 1LL * (s[i] - 'a' + 1) * pw[i] % mod + res[i - 1];",
    "            if (res[i] >= mod) res[i] -= mod;",
    "        }",
    "        return res;",
    "    }",
    "    ",
    "    int query(vector<int> &hash, vector<int> &pw, int l, int r, const int mod) {",
    "        int res = hash[r];",
    "        if (l > 0) res -= hash[l - 1];",
    "        if (res < 0) res += mod;",
    "        res = 1LL * res * pw[n - l] % mod;",
    "        return res;",
    "    }",
    "public:",
    "    Hash(string &s) {",
    "        n = s.size();",
    "        base1 = rand((int) 1e6, (int) 1e8);",
    "        base2 = rand((int) 1e6, (int) 1e8);",
    "        pw1.resize(n + 1), pw2.resize(n + 1);",
    "        pw1[0] = pw2[0] = 1;",
    "        for (int i = 1; i <= n; i++) {",
    "            pw1[i] = 1LL * base1 * pw1[i - 1] % mod1;",
    "            pw2[i] = 1LL * base2 * pw2[i - 1] % mod2;",
    "        }",
    "        hash1 = hash(s, pw1, mod1);",
    "        hash2 = hash(s, pw2, mod2);",
    "    }",
    "",
    "    long long get_hash(int l, int r) {",
    "        return 1LL * query(hash1, pw1, l, r, mod1) *",
    "               query(hash2, pw2, l, r, mod2);",
    "    }",
    "};",
    ""
  ],
  "description": "DoubleHashing"
}, 
"SingleHashing": {
  "prefix": "SingleHashing",
  "body": [
    "mt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());",
    "",
    "template<typename T>",
    "T rand(T l, T r) {",
    "    return uniform_int_distribution<T>(l, r)(rng);",
    "}",
    "",
    "struct Hash {",
    "private:",
    "    const int mod1 = 1e9 + 7;",
    "    int base1;",
    "    int n;",
    "    vector<int> pw1, hash1;",
    "",
    "    vector<int> hash(string &s, vector<int> &pw, const int mod) {",
    "        vector<int> res(n);",
    "        res[0] = (s[0] - 'a' + 1);",
    "        for (int i = 1; i < n; i++) {",
    "            res[i] = 1LL * (s[i] - 'a' + 1) * pw[i] % mod + res[i - 1];",
    "            if (res[i] >= mod) res[i] -= mod;",
    "        }",
    "        return res;",
    "    }",
    "    ",
    "    int query(vector<int> &hash, vector<int> &pw, int l, int r, const int mod) {",
    "        int res = hash[r];",
    "        if (l > 0) res -= hash[l - 1];",
    "        if (res < 0) res += mod;",
    "        res = 1LL * res * pw[n - l] % mod;",
    "        return res;",
    "    }",
    "public:",
    "    Hash(string &s) {",
    "        n = s.size();",
    "        base1 = rand((int) 1e6, (int) 1e8);",
    "        pw1.resize(n + 1);",
    "        pw1[0] = 1;",
    "        for (int i = 1; i <= n; i++) {",
    "            pw1[i] = 1LL * base1 * pw1[i - 1] % mod1;",
    "        }",
    "        hash1 = hash(s, pw1, mod1);",
    "    }",
    "    ",
    "    long long get_hash(int l, int r) {",
    "        return 1LL * query(hash1, pw1, l, r, mod1);",
    "    }",
    "};"
  ],
  "description": "SingleHashing"
},
"Compression": {
  "prefix": "CoordinateCompression",
  "body": [
    "struct coordinate_compression {",
    "private:",
    "    vector<long long> comp;",
    "",
    "    void compress() {",
    "        sort(comp.begin(), comp.end());",
    "        comp.erase(unique(comp.begin(), comp.end()), comp.end());",
    "    }",
    "",
    "public:",
    "    coordinate_compression(vector<long long> & v) {",
    "        comp = v; ",
    "        compress(); ",
    "    }",
    "",
    "    int get_index(long long val) {",
    "        return lower_bound(comp.begin(), comp.end(), val) - comp.begin(); ",
    "    }",
    "",
    "    int get_origin(size_t idx) {",
    "        return comp[idx]; ",
    "    }",
    "};"
  ],
  "description": "Compression"
}, 
"DisjointUnion": {
  "prefix": "DSU",
  "body": [
    "struct DSU {",
    "    vector<int> leader, rank;",
    "",
    "    DSU(int n) {",
    "        leader.resize(n + 1);",
    "        rank.resize(n + 1);",
    "        for (int i = 0; i <= n; ++i) {",
    "            leader[i] = i;",
    "            rank[i] = 1;",
    "        }",
    "    }",
    "",
    "    int find_leader(int u) {",
    "        return leader[u] = leader[u] == u ? u : find_leader(leader[u]);",
    "    }",
    "",
    "    bool is_same_set(int u, int v) {",
    "        return find_leader(u) == find_leader(v);",
    "    }",
    "",
    "    bool unite(int u, int v) {",
    "        u = find_leader(u), v = find_leader(v);",
    "        if (u == v) return false;",
    "",
    "        if (rank[u] > rank[v]) swap(u, v);",
    "",
    "        leader[u] = v;",
    "        rank[v] += rank[u];",
    "        return true;",
    "    }",
    "};"
  ],
  "description": "DisjointUnion"
},
"KMP": {
  "prefix": "KMP",
  "body": [
    "vector<int> buildLPS(string &pattern) {",
    "    int sz = (int)pattern.size();",
    "    vector<int> lps(sz, 0); ",
    "    int len = 0; ",
    "",
    "    for (int i = 1; i < sz; ++i) {",
    "        if (pattern[i] == pattern[len]) {",
    "            lps[i] = ++len;",
    "        } else {",
    "            if (len != 0) {",
    "                len = lps[len - 1];",
    "                --i; ",
    "            } else {",
    "                lps[i] = 0;",
    "            }",
    "        }",
    "    }",
    "    return lps;",
    "}",
    "",
    "bool KMP(string &s, string &pat) {",
    "    vector<int> lps = buildLPS(pat); ",
    "    int i = 0, j = 0; ",
    "    while (i < (int)s.size()) {",
    "        if (s[i] == pat[j]) {",
    "            i++;",
    "            j++;",
    "            if (j == (int)pat.size()) return true; ",
    "        } else {",
    "            if (j != 0) {",
    "                j = lps[j - 1];",
    "            } else {",
    "                i++;",
    "            }",
    "        }",
    "    }",
    "    return false; ",
    "}",
    ""
  ],
  "description": "KMP"
},
"NaiveSieve": {
  "prefix": "Sieve",
  "body": [
    "constexpr int N = 1e6 + 5;",
    "vector<bool> is_prime(N, true); ",
    "void NaiveSieve(long long n) {",
    "    is_prime[0] = is_prime[1] = false;",
    "    for (long long i = 2; i <= n; i++) {",
    "        if (is_prime[i]) { ",
    "            for (long long j = i + i; j <= n; j += i) {",
    "                is_prime[j] = false;  ",
    "            }",
    "        }",
    "    }",
    "}"
  ],
  "description": "NaiveSieve"
},
"PrimeFactors": {
  "prefix": "PrimeFactors",
  "body": [
    "vector<long long> primeFactors(long long x) {",
    "    vector<long long> factors;",
    "    for (int i = 2; i * i <= x; ++i) {",
    "        while (x % i == 0) {",
    "            factors.push_back(i);",
    "            x /= i;",
    "        }",
    "    }",
    "",
    "    if (x > 1) {",
    "        factors.push_back(x);",
    "    }",
    "",
    "    return factors;",
    "}"
  ],
  "description": "PrimeFactors"
},
"SegmentTree": {
  "prefix": "SegmentTree",
  "body": [
    "struct Node {",
    "    int sum;",
    "",
    "    Node() : sum(0) { }",
    "    Node(int x) : sum(x) { }",
    "    void change(int x) {",
    "        sum = x;",
    "    }",
    "};",
    "",
    "struct Sagara {",
    "#define LeftChild  (node * 2 + 1)",
    "#define RightChild (node * 2 + 2)",
    "#define mid        (l + r >> 1)",
    "",
    "private:",
    "    vector<Node> segData;",
    "    int tree_size;",
    "",
    "    void build(vector<int> &arr, int node, int l, int r) {",
    "        if (r - l == 1) {",
    "            if (l < arr.size()) {",
    "                segData[node] = Node(arr[l]);",
    "            }",
    "            return;",
    "        }",
    "",
    "        build(arr, LeftChild, l, mid);",
    "        build(arr, RightChild, mid, r);",
    "",
    "        segData[node] = merge(segData[LeftChild], segData[RightChild]);",
    "    }",
    "",
    "    Node merge(Node &l, Node &r) {",
    "        Node ans = Node();",
    "        ans.sum = l.sum + r.sum;",
    "        return ans;",
    "    }",
    "",
    "    void update(int idx, int val, int node, int l, int r) {",
    "        if (r - l == 1) {",
    "            segData[node].change(val);",
    "            return;",
    "        }",
    "",
    "        if (idx < mid) {",
    "            update(idx, val, LeftChild, l, mid);",
    "        } else {",
    "            update(idx, val, RightChild, mid, r);",
    "        }",
    "",
    "        segData[node] = merge(segData[LeftChild], segData[RightChild]);",
    "    }",
    "",
    "    Node query(int left, int right, int node, int l, int r) {",
    "        if (l >= left and r <= right) return segData[node];",
    "        if (l >= right or left >= r) return Node();",
    "",
    "        Node L = query(left, right, LeftChild, l, mid);",
    "        Node R = query(left, right, RightChild, mid, r);",
    "",
    "        return merge(L, R);",
    "    }",
    "",
    "public:",
    "    Sagara(int n, vector<int> &arr) {",
    "        tree_size = 1;",
    "        while (tree_size < n) tree_size <<= 1;",
    "        segData = vector<Node>(2 * tree_size);",
    "        build(arr, 0, 0, tree_size);",
    "    }",
    "",
    "    void update(int idx, int val) {",
    "        update(idx, val, 0, 0, tree_size);",
    "    }",
    "",
    "    int query(int left, int right) {",
    "        return query(left, right, 0, 0, tree_size).sum;",
    "    }",
    "",
    "#undef LeftChild",
    "#undef RightChild",
    "#undef mid",
    "};"
  ],
  "description": "SegmentTree"
},
"SegmentTreeWithLazy": {
  "prefix": "SegmentTreeWithLazy",
  "body": [
    "struct Node {",
    "    int sum, lazy = 0;",
    "    bool isLazy = false;",
    "",
    "    Node() : sum(0) { }",
    "    Node(int x) : sum(x) {}",
    "    void updateNode(int x, int lx, int rx) {",
    "        sum += x * (rx - lx);",
    "        lazy += x;",
    "        isLazy = true;",
    "    }",
    "};",
    "",
    "",
    "struct SagaraWithLazy {",
    "#define leftChild  (node * 2 + 1)",
    "#define rightChild (node * 2 + 2)",
    "#define mid        ((lx + rx >> 1))",
    "",
    "    int treeSize;",
    "    vector<Node> segData;",
    "",
    "    void build(int node, int lx, int rx, vector<int>& arr) {",
    "        if (rx - lx == 1) {",
    "            if (lx < (int)arr.size())",
    "                segData[node] = Node(arr[lx]);",
    "            return;",
    "        }",
    "",
    "        build(leftChild, lx, mid, arr);",
    "        build(rightChild, mid, rx, arr);",
    "",
    "        segData[node] = merge(segData[leftChild], segData[rightChild]);",
    "    }",
    "",
    "    Node merge(Node& L, Node& R) {",
    "        Node res = Node();",
    "        res.sum = L.sum + R.sum;",
    "        return res;",
    "    }",
    "",
    "",
    "    void propagate(int node, int lx, int rx) {",
    "        if (rx - lx == 1 or !segData[node].isLazy) return;",
    "",
    "        segData[leftChild].updateNode(segData[node].lazy, lx, mid);",
    "        segData[rightChild].updateNode(segData[node].lazy, mid, rx);",
    "",
    "        segData[node].isLazy = segData[node].lazy = 0;",
    "    }",
    "",
    "    void update(int l, int r, int x, int node, int lx, int rx) {",
    "        propagate(node, lx, rx);",
    "",
    "        if (l >= rx or lx >= r) return;",
    "        if (l <= lx and rx <= r) {",
    "            segData[node].updateNode(x, lx, rx);",
    "            return;",
    "        }",
    "",
    "        update(l, r, x, leftChild, lx, mid);",
    "        update(l, r, x, rightChild, mid, rx);",
    "",
    "        segData[node] = merge(segData[leftChild], segData[rightChild]);",
    "    }",
    "",
    "",
    "    Node query(int l, int r, int node, int lx, int rx) {",
    "        propagate(node, lx, rx);",
    "",
    "        if (l >= rx or lx >= r) return Node();",
    "        if (l <= lx and rx <= r) {",
    "            return segData[node];",
    "        }",
    "",
    "        Node left = query(l, r, leftChild, lx, mid);",
    "        Node right = query(l, r, rightChild, mid, rx);",
    "",
    "        return merge(left, right);",
    "    }",
    "",
    "public:",
    "    SagaraWithLazy(int n, vector<int>& arr) {",
    "        treeSize = 1;",
    "        while (treeSize < n) treeSize <<= 1;",
    "        segData = vector<Node>(treeSize << 1);",
    "        build(0, 0, treeSize, arr);",
    "    }",
    "",
    "    void update(int l, int r, int x) {",
    "        update(l, r, x, 0, 0, treeSize);",
    "    }",
    "",
    "    int query(int l, int r) {",
    "        return query(l, r, 0, 0, treeSize).sum;",
    "    }",
    "#undef LeftChild",
    "#undef RightChild",
    "#undef mid",
    "};"
  ],
  "description": "SegmentTreeWithLazy"
},
"CheckIsBipartite": {
  "prefix": "CheckBibartite",
  "body": [
    "vector<int> color(N);",
    " ",
    "bool dfs_check_bipartite(int u) {",
    "    bool can = true;",
    "    for (auto v: adj[u]) {",
    "        if (!color[v]) {",
    "            color[v] = 3 - color[u];",
    "            can &= dfs_check_bipartite(v);",
    "        } else if (color[v] == color[u]) {",
    "            return false;",
    "        }",
    "    }",
    "    return can;",
    "}",
    " ",
    "bool bfs_check_bipartite(int st) {",
    "    queue<int> q;",
    "    q.push(st);",
    "    color[st] = 1;",
    "    while (!q.empty()) {",
    "        int u = q.front();",
    "        q.pop();",
    " ",
    "        for (auto v: adj[u]) {",
    "            if (!color[v]) {",
    "                color[v] = 3 - color[u];",
    "                q.push(v);",
    "            } else if (color[u] == color[v]) {",
    "                return false;",
    "            }",
    "        }",
    "    }",
    "    return true;",
    "}"
  ],
  "description": "CheckIsBipartite"
},
"fastPower": {
  "prefix": "fastPower",
  "body": [
    "long long fastPower(long long base, long long power, long long mod) {",
    "    long long res = 1;",
    "    while (power) {",
    "        if (power & 1) {",
    "            res = ((res % mod) * (base % mod)) % mod;",
    "            power -= 1;",
    "        } else {",
    "            base = ((base % mod) * (base % mod)) % mod;",
    "            power >>= 1;",
    "        }",
    "    }",
    "    return res;",
    "}"
  ],
  "description": "fastPower"
},
"multiplyStringWithInteger": {
  "prefix": "multiplyStringWithInteger",
  "body": [
    "string multiplyStrings(string a, int b) {",
    "    string result = \"\";",
    "    int carry = 0;",
    "    for (int i = a.size() - 1; i >= 0; i--) {",
    "        int prod = (a[i] - '0') * b + carry;",
    "        result = char((prod % 10) + '0') + result;",
    "        carry = prod / 10;",
    "    }",
    "    while (carry) {",
    "        result = char((carry % 10) + '0') + result;",
    "        carry /= 10;",
    "    }",
    "    return result;",
    "}"
  ],
  "description": "multiplyStringWithInteger"
},
"PrefixFrequencyCharacters": {
  "prefix": "PrefixFrequencyCharacters",
  "body": [
    "constexpr int N = 1e5+5;",
    "vector<vector<int>> prefix_freq(N, vector<int>(26, 0));",
    "void pre(string s) {",
    "    prefix_freq[0][s[0] - 'a'] = 1;",
    " ",
    "    for (int i = 1; i < sz(s); ++i) {",
    "        for (int ch = 0; ch < 26; ++ch)",
    "            prefix_freq[i][ch] = prefix_freq[i - 1][ch];",
    " ",
    "        prefix_freq[i][s[i] - 'a']++;",
    "    }",
    "}",
    " "
  ],
  "description": "PrefixFrequencyCharacters"
},
"Debugger": {
  "prefix": "ShowDebug",
  "body": [
    "#define debug(x)         cout << #x << \" = \" << x << \"\\n\";",
    "#define vdebug(a)        cout << #a << \" = \"; for(auto x: a) cout << x << \" \"; cout << \"\\n\";"
  ],
  "description": "Debugger"
},
"PrefixSum2D": {
  "prefix": "PrefixSum2D",
  "body": [
    "struct prefix_2D {",
    "    int n, m;",
    "    vector<vector<int>> pre;",
    "",
    "    prefix_2D(const vector<vector<int>> & matrix) {",
    "        n = matrix.size() - 1;",
    "        m = matrix[0].size() - 1;",
    "        pre = vector (n + 1, vector<int> (m + 1));",
    "",
    "        buildPrefix2D(matrix);",
    "    }",
    "",
    "    void buildPrefix2D(const vector<vector<int>> & matrix) {",
    "        for (int i = 1; i <= n; ++i) {",
    "            for (int j = 1; j <= m; ++j) {",
    "                pre[i][j] = matrix[i][j] + pre[i][j - 1] + pre[i - 1][j] - pre[i - 1][j - 1];",
    "            }",
    "        }",
    "    }",
    "",
    "    void printPrefix() {",
    "        for (int i = 1; i <= n; ++i) {",
    "            for (int j = 1; j <= m; ++j) {",
    "                cout << pre[i][j] << \" \\n\"[j == m];",
    "            }",
    "        }",
    "    }",
    "",
    "    int query(int x1, int y1, int x2, int y2) {",
    "        if (x1 > x2) swap(x1, x2);",
    "        if (y1 > y2) swap(y1, y2);",
    "        return pre[x2][y2] - pre[x1 - 1][y2] - pre[x2][y1 - 1] + pre[x1 - 1][y1 - 1];",
    "    }",
    "};"
  ],
  "description": "PrefixSum2D"
},
"SparseTable": {
  "prefix": "SparseTable",
  "body": [
    "template<typename T, class CMP = function<T(const T &, const T &)>> ",
    "struct Sparse_Table {",
    "    int n;",
    "    CMP merge;",
    "    vector<vector<T>> sp;",
    "",
    "    Sparse_Table(const vector<T>& arr, const CMP &F) : merge(F) {",
    "        n = arr.size();",
    "        int maxLog = 32 - __builtin_clz(n);",
    "        sp.resize(maxLog);",
    "        sp[0] = arr;",
    "        for (int lg = 1; lg < maxLog; ++lg) {",
    "            sp[lg].resize(n - (1 << lg) + 1);",
    "            for (int i = 0; i + (1 << lg) <= n; ++i) {",
    "                sp[lg][i] = merge(sp[lg - 1][i], sp[lg - 1][i + (1 << (lg - 1))]);",
    "            }",
    "        }",
    "    }",
    "",
    "    T query(int l, int r) {",
    "        int lg = __lg(r - l + 1);",
    "        return merge(sp[lg][l], sp[lg][r - (1 << lg) + 1]);",
    "    }",
    "};"
  ],
  "description": "SparseTable"
},"OrederedSet": {
  "prefix": "getOrederedSet",
  "body": [
    "#include <ext/pb_ds/assoc_container.hpp>",
    "#include <ext/pb_ds/tree_policy.hpp>",
    "using namespace __gnu_pbds;",
    "typedef tree<int, null_type, less<int>, rb_tree_tag,",
    "    tree_order_statistics_node_update>",
    "    ordered_set;"
  ],
  "description": "OrederedSet"
},"GPHashMap": {
  "prefix": "getHashMap",
  "body": [
    "#include<ext/pb_ds/assoc_container.hpp>",
    "#include<ext/pb_ds/tree_policy.hpp>",
    "using namespace std;",
    "using namespace __gnu_pbds;",
    "",
    "struct custom_hash {",
    "  static uint64_t splitmix64(uint64_t x) {",
    "    x += 0x9e3779b97f4a7c15;",
    "    x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;",
    "    x = (x ^ (x >> 27)) * 0x94d049bb133111eb;",
    "    return x ^ (x >> 31);",
    "  }",
    "  size_t operator()(uint64_t x) const {",
    "    static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();",
    "    return splitmix64(x + FIXED_RANDOM);",
    "  }",
    "};",
    "",
    "gp_hash_table<int, int, custom_hash> hashmap;"
  ],
  "description": "GPHashMap"
},
"XORTrie": {
  "prefix": "XORTrie",
  "body": [
    "struct BinaryTrie {",
    "    struct Node {",
    "        Node* child[2];",
    "        int freq[2];",
    "        Node() {",
    "            child[0] = child[1] = nullptr;",
    "            freq[0] = freq[1] = 0;",
    "        }",
    "    };",
    "    Node* root;",
    "    const int B = 30;",
    "    BinaryTrie() {",
    "        root = new Node();",
    "        insert(0);",
    "    }",
    "    void insert(int x) {",
    "        Node* cur = root;",
    "        for (int i = B; ~i; --i) {",
    "            bool idx = (x >> i) & 1;",
    "            if (cur->child[idx] == nullptr) {",
    "                cur->child[idx] = new Node();",
    "            }",
    "            cur->freq[idx]++;",
    "            cur = cur->child[idx];",
    "        }",
    "    }",
    "    void del(int x, int b, Node* cur) {",
    "        if (b == -1) return;",
    "        bool idx = (x >> b) & 1;",
    "        del(x, b - 1, cur->child[idx]);",
    "        cur->freq[idx]--;",
    "        if (cur->freq[idx] == 0) {",
    "            delete cur->child[idx];",
    "            cur->child[idx] = nullptr;",
    "        }",
    "    }",
    "    void delete_(int x) {",
    "        del(x, B, root);",
    "    }",
    "",
    "    bool search(int x) {",
    "        Node* cur = root;",
    "        for (int i = B; ~i; --i) {",
    "            bool idx = (x >> i) & 1;",
    "            if (cur->child[idx] == nullptr) {",
    "                return false;",
    "            }",
    "            cur = cur->child[idx];",
    "        }",
    "        return true;",
    "    }",
    "",
    "    int query(int x) {",
    "        Node* cur = root;",
    "        int ret = 0;",
    "        for (int i = B; ~i; --i) {",
    "            bool idx = (x >> i) & 1;",
    "            if (cur->child[idx ^ 1] != nullptr) {",
    "                cur = cur->child[idx ^ 1];",
    "                ret |= (1 << i);",
    "            } else {",
    "                cur = cur->child[idx];",
    "            }",
    "        }",
    "        return ret;",
    "    }",
    "};"
  ],
  "description": "XORTrie"
},"Combinatorics": {
  "prefix": "Combinatorics",
  "body": [
    "namespace combinatorics",
    "{",
    "    int MOD;",
    "    vector<int> fac, inv, finv;",
    "    int nCr(int x,int y) {",
    "        if(x < 0 || y > x || y < 0) return(0);",
    "        return(fac[x] * finv[y] % MOD * finv[x-y] % MOD);",
    "    }",
    "    int nPr(int x,int y) {",
    "        if(x < 0 || y > x || y < 0) return(0);",
    "        return fac[x] * finv[x-y] % MOD;",
    "    }",
    "    int power(int b,int n) {",
    "        b %= MOD;",
    "        int s = 1;",
    "        while(n) {",
    "            if(n & 1) s = s * b % MOD;",
    "            b = b * b % MOD;",
    "            n /= 2;",
    "        }",
    "        return s;",
    "    }",
    "    void init(int n,int mod) {",
    "        fac.resize(n + 1);",
    "        inv.resize(n + 1);",
    "        finv.resize(n + 1);",
    "        MOD = mod;",
    "        fac[0] = inv[0] = inv[1] = finv[0] = finv[1] = 1;",
    "        for(int i = 1;i <= n; ++i) fac[i] = fac[i - 1] * i % MOD;",
    "        for(int i = 2; i <= n; ++i) inv[i] = MOD - MOD / i * inv[MOD % i] % MOD;",
    "        for(int i = 2; i <= n; ++i) finv[i] = finv[i - 1] * inv[i] % MOD;",
    "    }",
    "    int mul(int a,int b) {",
    "        return ((a % MOD) * (b % MOD)) % MOD;",
    "    }",
    "    int add(int a,int b) {",
    "        return ((a % MOD) + (b % MOD)) % MOD;",
    "    }",
    "    int sub(int a,int b) {",
    "        return (((a - b) % MOD) + MOD) % MOD;",
    "    }",
    "    int divide(int a,int b) {",
    "        return mul(a,power(b,MOD - 2));",
    "    }",
    "    int Inv(int x) {",
    "        return power(x,MOD - 2);",
    "    }",
    "    int catalan(int n) {",
    "        return (nCr(2 * n,n) * Inv(n + 1)) % MOD;",
    "    }",
    "    int StarsAndPars(int n,int k) {",
    "        return nCr(n + k - 1,k - 1);",
    "    }",
    "};",
    "using namespace combinatorics;",
    ""
  ],
  "description": "Combinatorics"
},"DoubleHashing2": {
  "prefix": "MyHashing",
  "body": [
    "constexpr int N = 2e5 + 5;",
    "",
    "constexpr int MOD1 = 1000000007, MOD2 = 1000000009, p1 = 133, p2 = 137;",
    "vector<int> pow1, pow2;",
    "",
    "void preCompute(int n) {",
    "    pow1.resize(n + 1), pow2.resize(n + 1);",
    "    pow1[0] = pow2[0] = 1;",
    "    for (int i = 1; i <= n; ++i) {",
    "        pow1[i] = (pow1[i - 1] * p1) % MOD1;",
    "        pow2[i] = (pow2[i - 1] * p2) % MOD2;",
    "    }",
    "}",
    "",
    "struct Hash {",
    "    vector<int> hash1, hash2;",
    "",
    "    Hash () {}",
    "",
    "    Hash(const string& s) {",
    "        int n = s.size();",
    "        hash1.resize(n + 1, 0), hash2.resize(n + 1, 0);",
    "        for (int i = 0; i < n; ++i) hash1[i + 1] = ((hash1[i] * p1) % MOD1 + (s[i] - 'a' + 1)) % MOD1; // 1-based",
    "        for (int i = 0; i < n; ++i) hash2[i + 1] = ((hash2[i] * p2) % MOD2 + (s[i] - 'a' + 1)) % MOD2; // 1-based",
    "    }",
    "",
    "    pair<int, int> getHash(int l, int r) {",
    "        if (l > r) return {0, 0};",
    "        l += 1;",
    "        r += 1;",
    "        int len = r - l + 1;",
    "",
    "        int h1 = (hash1[r] - (hash1[l - 1] * 1ll * pow1[len]) % MOD1 + MOD1) % MOD1;",
    "        int h2 = (hash2[r] - (hash2[l - 1] * 1ll * pow2[len]) % MOD2 + MOD2) % MOD2;",
    "",
    "        return {h1, h2};",
    "    }",
    "};",
    ""
  ],
  "description": "DoubleHashing"
},
"FenwickTree": {
  "prefix": "FenwickTree",
  "body": [
    "template<class T>",
    "struct Fenwick {",
    "    int n;",
    "    vector<T> a, bit;",
    " ",
    "    Fenwick(int _n = 0) {",
    "        n = _n + 1;",
    "        a = bit = vector<T>(n + 1);",
    "    }",
    " ",
    "    void add(int idx, T delta) {",
    "        a[idx] += delta;",
    "        for (int i = idx + 1; i <= n; i += i & -i) bit[i] += delta;",
    "    }",
    " ",
    "    void set(int idx, T val) { add(idx, val - a[idx]); }",
    " ",
    "    T query(int idx) {",
    "        T sum = 0;",
    "        for (int i = idx + 1; i >= 1; i -= i & -i) sum += bit[i];",
    "        return sum;",
    "    }",
    " ",
    "    T query(int l, int r) { return query(r) - query(l - 1); }",
    "};",
    " "
  ],
  "description": "FenwickTree"
},
}
